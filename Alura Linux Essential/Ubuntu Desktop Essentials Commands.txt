
-- terminal: (o app do terminal executa um console, que roda um programa chamado shell do interpretador bash)
-- command options arguments    ex: type -t ls                    obs: no geral segue esta ordem, mas existem comandos que fogem a regra

==============COMANDOS NO TERMINAL========================================================================================================================================
$ man dpkg                 => Ver manual do dpkg
$ man -k printf            => Com o -k buscamos a palavra chave e buscamos diversas referências para a palavra chave.
$ dpkg --list              => ver todos os pacotes instalados
$ sudo dpkg -i nomedoarquivo.deb        => instala um pacote
$ sudo dpkg -r nomedoarquivo.deb        => remove o pacote
$ sudo dpkg -P ou --purge               => apaga o pacote e todos os arquivos relacionados
$ passwd => para alterar a senha do super usuário
$ sudo apt-get install nomedopacote
$ sudo apt-get -f install               => instala todas as dependências não resolvidas do nosso sources.list
$ ls      => lista os arquivos da pasta atual
$ ls -l   =>  lista com detalhes, teremos o conteúdo de dentro do diretório
$ ls --help => mostra o help do ls, ou seja, obter ajuda para comandos externos (não builtin) normalmente utiliza-se a opção --help.
$ ls -h     => -h abreviação do --help, mas apresenta comportamento inesperado
$ ls -a   => lista todos os arquivos inclusive os ocultos que iniciam com .
$ ls -la  => executa o all e o type (-a e -t) juntos
$ ls -d   => O ls tem uma opção que se chama -d minúsculo e quando usamos essa opção o que estamos dizendo é que queremos analisar um diretório específico.
$ ls -ld  => Se quisermos ver informações sobre o diretório em si, e não sobre o conteúdo do diretório
$ ls -i || ls --inode  =>  Cada arquivo é representado por um ou mais nós que trazem a informação base dos arquivos que estão ligados que por sua vez estão ligados a outros nós que estão ligados a outros nós que trazem dados de arquivos, diretórios e etc e assim por diante. Então, é um pouco uma árvore que vai se interligando com todos esses nós. Temos, ainda, uma opção do ls que é o ls -i que mostra a informação desses nós.
$ ls --color=auto           => coloca uma cor para diferenciar os itens listados, branco, se for normal, verde se for executável, azul escuro se for diretório e azul claro se for um link.
$ ls -F             => indica, visualmente, através de caracteres o que cada coisa que está na lista é. Um arquivo normal não possui nenhum carácter, um arquivo executável possui um asterisco, um diretório é marcado pela barra e um link possui um arroba.
$ ls bemvindo*      => lista todos os arquivos com bemvindo - output: bemvindo.txt bemvindo2.txt
$ ls *              => mostra os diretórios atuais e entra neles em um nível dos diretórios filhos (ls -R entra em mais de um nível)
$ ls *.txt          => mostra todos os arquivos .txt
$ ls --reverse || ls -r     =>Para modificar a ordenação podemos digitar ls --reverse que estaremos pedindo: "Porfavor, reverta a ordem" e ele trará do "z" até o "a"
$ ls --sort=size || ls -S   => exibe por odem de tamanho (mas não podemos ver o tamanho dos arquivos)
$ ls --format=long ||ls -l  => Para ver em uma lista onde podemos confirmar o tamanho dos arquivos. Para verificar mais informações em uma lista longa podemos dizer ao ls para formatar a sua saída em um formato longo.
      ex: /bin/ls --format=long --reverse --sort=size
$ ls --sort=time ||ls -t    => mostrar por tempo de criação
$ ls --recursive ||ls -R    => Mostra os diretórios atuais mas também todos os arquivos filhos deles de maneira recursiva
$ zip bemvindo.zip *.txt    => zipa todos os arquivos .txt e guarda tudo na bemvindo.zip
$ cat arquivo.txt   => mostra o conteúdo de arquivos.txt
$ cat texto*.txt    => mostra o conteúdo de todo arquivo "texto + alguma coisa + .txt"
$ cat texto?.txt    => mostra o conteúdo de todo arquivo "texto + algum caracter + .txt" obs: apenas um caracter seja número, letra, etc
$ cat arquivo[123].txt  => mostra arquivo1.txt arquivo2.txt arquivo3.txt
$ cat arquivo[12].txt  => mostra arquivo1.txt arquivo2.txt
$ cat arquivo[0-9].txt  => mostra arquivo0.txt até o arquivo9.txt
$ cat arquivo[A-Z].txt   => Com isso estamos dizendo que queremos um carácter qualquer de A até Z, escrito em letras maiúsculas
$ cat arquivo[a-z].txt   => fornecerá qualquer letra minúscula.
$ cat {arquivo*, texto?.txt}  => Pegaremos tudo o que começa com arquivo, mas queremos pegar também todos os arquivos que começam com texto, seguidos de qualquer coisa (?) e tendo no fim .txt. Para dizer que queremos ou o primeiro padrão ou o segundo, colocamos isso dentro de chaves
$ type    => verificar o tipo de um comando ex: type ls / type echo
$ cd 'nome da pasta'    => entra na pasta/diretório
$ cd ..                 => para voltar uma pasta
$ cd -                  =>  Podemos nem lembrar qual era o diretório que estávamos antes, o último diretório que utilizamos. Para isso digitaremos cd -. O hífen é utilizado para voltarmos ao último diretório que estávamos utilizando.
$ locate arquivo/programa/etc     => Busca no sistema inteiro o parâmetro digitado. O locate possui um banco de dados onde ele armazena todos os arquivos que existem, isto é, arquivos que ele é capaz de localizar. Então, isso é um banco de dados que ele mantêm e, por isso, toda vez que buscamos algo ele não necessita sair varrendo todos os arquivos e todos os diretórios para achar o que queremos. Ele vai rapidamente nesse banco de dados, que contem todos os nomes de diretórios e arquivos, encontra o que solicitamos e nos traz o que buscávamos. Esse é um processo que já está otimizado, como o locate é bastante utilizado no dia a dia ele simplesmente mantêm tudo já otimizado para realizar a busca.
$ sudo updatedb                   => Quando apagamos arquivos ou adicionamos, precisamos atualizar o bando de dados para que o locate busque corretamente os arquivos
$ locate -e texto                 => Podemos rodar um locate com a opção -e que é de arquivos apagados e arquivos que não existem mais. Então, ele não vai mais nos mostrar arquivos que não existem mais.
$ locate "*/log-*"                => irá buscar todos os arquivos que "diretório qualquer + log- + qualquer coisa"
$ sudo apt-get install mlocate    => nem todo SO tem o Locate instalado, para instalar digite esse comando
$ mkdir     => para criar uma pasta
$ mkdir -p  => cria várias pastas que você informar caso elas não existam ex: mkdir -p Pictures/fotos/2020/trimestre1
$ mkdir -p Pictures/foto/201{1,2,3,4,5}/trimestre{1,2,3,4}  => usamos globbing para criar as pastas 2011, 2012, 2013 ..., todas com trimestre 1234 dentro de cada uma
$ mkdir -pv ferias/201{3,4,5}/{julho,dezembro}   => Utilizando o mkdir e o globbing crie o diretório ferias dentro do diretório Pictures, e dentro dele os diretórios 2013, 2014 e 2015. Dentro de cada um desses três diretórios, crie os diretórios julho e dezembro.
$ mkdir -pv => É possível também combinar o -p com a opção -v (verbose), que irá listar todas as operações que estão sendo feitas
$ rmdir     => remove um diretório se ele estiver vazio  ex: rmdir Pictures/fotos/2020/trimestre1  -  removerá apenas trimestre1
$ rmdir -p  => remove os diretórios enquanto estiverem vazios ex: rmdir -p Pictures/fotos/2019/trimestre1 Primeiro o rmdir irá remover o diretório trimestre1. A partir desse momento o diretório 2019 não está mais vazio e também será removido. Como o diretório fotos possui outros diretório, ele não é removido. Se tivéssemos uma sequência de diretórios vazios, todos seriam removidos.
$ rm loja/*  => remove todo dir vazio que estiver dentro de loja
$ rm -i loja/*  => pergunta se quer remover todo dir vazio que estiver dentro de loja
$ rm -r loja/*  => remove tudo o que estiver dentro de loja de maneira recursiva (-r e -R tanto faz)
$ rm -rfi 'nome da pasta'  => remover uma pasta de maneira forçada (-f), de maneira recursiva (-r) e de maneira interativa para te perguntar sobre cada passo (i) {i serve como segurança, caso você digite "rm -fv arquivos /" com este espaço errado vc apaga tudo desde o dir raiz}
$ rm
$ touch     => O comando touch altera a data de modificação de um arquivo para a data e hora atuais do sistema. O conteúdo do arquivo em si não é modificado, é como se apenas "tocássemos" no arquivo. Caso o arquivo não exista, o comportamento padrão é criar o arquivo.
$ -a        => tudo (all)   ex: type -a ls
$ -t        => tipo (type)  ex: type -t ls    (output: builtin   --> significa que ls é um comando interno do bash e não um programa instalado)
$ apt-get   => instala os pacotes e todas as dependências 
$ dpkg    => instala um único pacote .deb que for informado  Ex: mysql5.6....deb
$ echo    =>  ex: echo Mateus, bom dia! -- devolve o que eu digitei (como se fosse um print)
$ pwd     => mostra o diretório atual
$ whoami  => mostra o seu User
$ zip     => compacta arquivos do meu diretório
$ unzip   => descompacta arquivos
$ unzip -l work.zip               => mostra todos os arquivos compactados na pasta work.zip
$ data    => data atual
$ help    => mostra informações de um comando, O help nos ajuda referente as funções de coisas definidas em cima do shell, isto é, nos builtin do shell. ex: help type 
$ less texto1.txt  => less é o nome de um visualizador, o mesmo que é exibido quando usamos o comando "$ man ". Utilizamos as setas para navegar, espaço para ir para frente, / para buscarmos alguma coisa, então, por exemplo, vamos buscar aquela "Linha 253", digitando /25 ele busca isso para nós e usamos o q para sair.
$ env     => (environment) mostra todas as variáveis de ambiente criadas
$ df -h                             => lista os dispositivos montados (hds, ssds, etc)
$ chown                             => significa change ownership, usada para mudar permissões
$ chmod +x arquivo                  => conseguir permissão de execução de um arquivo (torná-lo executável)
$ mv loja/mensagem.txt loja/bemvindo2.txt     => Move o mensagem.txt para bemvindo2.txt o "renomeando-o" (maneira de renomear arquivos)
$ mv loja/mensagem.txt Documents/             => Move o mensagem.txt para Documents
$ cp arquivo.txt arquivo2.txt       => copia o arquivo.txt, e cria o arquivo2.txt com as mesmas informações do primeiro
$ cp -R projetos-java/ projetos-c#/ => Para copiar o diretório projetos-java para o diretório projetos-c#, passamos o -R como argumento para o cp, para que ele possa copiar os diretórios de maneira recursiva
$ cp -R loja loja_nova              => copia de maneira recursiva tudo o que está no dir loja para loja_nova
$ cp loja/contato.html loja2        => copiando o arquivo contato.html para o diretório loja2
$ cp -i loja/bemvindo.html loja/bemvindo2.html => O cp subscreve, então, temos que tomar muito cuidado quando utilizamos o copy, quando copiamos um arquivo para outro arquivo. Tanto que muitas vezes o que fazemos é o cp e pedimos para ele nos perguntar antes o que devemos fazer, para isso, digitamos cp -i, ele nos perguntará se queremos subscrever: "*overwrite 'loja/bemvindo2.html' ? *". E como não queremos que nada seja subscrito , digitaremos apenas um n, de "no" para dizermos que não queremos que seja subscrito
$ cp loja/bemvindo1.html loja/bemvindo2.html loja3/  => copia os arquivos bemvindo{1,2}.html para o diretório loja3
$ cp -v loja/bemvindo1.html loja/bemvindo2.html loja5/ => copia bemvindo{1,2}.txt para loja5 mas exibe no terminal (de forma mais visual) o que está ocorrendo com o parâmetro -v de --verbose
$ cp -vu loja/* lojabackup/      => copia todo arquivo que sofreu alguma atualização (-u de update) em loja, para o dir lojabackup
$ cp -b loja/* loja2             => Se já existir, um arquivo com esse nome "loja2" podemos simplesmente fazer um backup desse arquivo e, para isso, usamos o -b de backup. Podemos verificar que temos dois tipos de arquivo, aqueles que possuem um til e que representam a versão antiga dos arquivos e os que estão sem o acento que representam a versão nova. O til (~) no final, no último carácter, portanto, é um padrão para indicar que determinado arquivo é um backup de um arquivo que tínhamos.
$ history        => mostra o histórico de comandos executados no shell
$ which nome_do_programa          => mostra qual executável será executado - ex: wich zip - output: /user/bin/zip
$ which -a nome_do_programa       => mostra todos os caminhos que se relacionem com este
$ whereis zip                     => Ele nos mostra que o zip está em usr/bin/zip, e em /home/guilherme/zip e temos também um manual do zip, o /usr/share/man/man1/zip.1.gz
$ echo $?                         => Estamos perguntando qual é o último resultado que um comando, um programa teve. Se deu tudo "ok" o resultado é 0.
$ comando1 && comando 2           => O && é usado para falar que o segundo comando será executado apenas se o exit code do primeiro comando for igual a zero, isto é, apenas se o primeiro for sucesso. Assim, se o primeiro não tivesse sido executado com sucesso, o segundo comando não seria executado.
$ comando1 || comando 2           => Para dizermos o "ou" utilizamos o pipe duas vezes || , o pipe é também chamado de cano.
$ comando_qualquer ; echo "Bom dia"  => Para executar dois comandos em sequência, podemos utilizar o ; (ponto e vírgula). Os comandos serão executados independente do resultado do anterior.
$ du /arquivo/                       => Para descobrir quanto do disco que o diretório está usando basta ir até o terminal e dizer: "por favor, mostre-me o quanto do disco (du, disk usage) o diretório /arquivo||pasta||app/ está usando"
$ du -s /arquivo/                    => Queremos que o programa resuma sua saída e nos mostre apenas o total no diretório. Como queremos que ele sintetizar (-s, summarize) a informação
$ du -sh /arquivo/                   => A saída padrão do comando du mostra os números em kilobytes. Só que esse número não fica muito compreensível para nós, precisamos deixá-lo mais inteligível para humanos (-h). Podemos utilizar as duas expressões separadamente, -s -h, ou juntas -sh
$ df -h /arquivo/                    => Para saber o quanto do disco está sendo usado, utilizamos outro comando: df .Este retorna o espaço livre, ou ocupado, de cada partição no sistema. Da mesma forma que fazemos com o du, podemos especificar o diretório, assim, ele retorna somente a partição da qual esse diretório pertence. Podemos também utilizar a opção -h e teremos uma saída mais legível
================================================================================================================================================================

======== DIRETÓRIOS IMPORTANTES===============================================================================================================================================
/etc/apt/sources.list       => The sources.list file is a key factor in adding or upgrading applications to your Ubuntu installation. This is also used by your system for system updates. The file is basically the roadmap for your system to know where it may download programs for installation or upgrade.
$ ls /usr/share/doc             => Então, no diretório /usr/share/docs é comum termos documentação sobre as mais variadas coisas, programas, comandos e etc. Nesse diretório é onde os programas instalam suas documentações, por padrão. Então, podemos, por exemplo, buscar a documentação do zip. Para isso, digitaremos ls /usr/share/doc/zip (irá aparecer no caso do zip que o software sofreu atualizações, então digite $less /usr/share/doc/zip/WHATSNEW)
================================================================================================================================================================

======== Atalhos ===============================================================================================================================================
windows + shift + pagedn ou pageup     => enviar um app para outra workspace
windows pagedn ou pageup     => ficar alternando
ctrl + alt + f1/f2/f3/f4/f5/f6 para abrir os 6 consoles possíveis, f7 para o console gráfico
ctrl + l  => limpa o console
ctrl + a  => vai para o inicio da frase
ctrl + e  => vai para o final da frase
ctrl + c  => encerrar a atividade
ctrl + d  => encerrar a atividade ex: python
ctrl + r  => abre uma busca, para que eu pesquise qual comando eu quero resgatar do meu histórico de comandos
================================================================================================================================================================

==========VARIÁVEIS DE AMBIENTE E LOCAIS========================================================================================================================
criei um arquivo de texto chamado mostra_idade em mateus@mateus-VitualBox == /home/mateus
digite os comandos abaixo para relembrar variáveis de ambiente e de shell
$ env FULL_NAME='Mateus V de Castro' AGE=19 OPERATIONAL_SYSTEM='Linux UBUNTU' bash mostra_idade
$ export NOME='Daniel'
$ echo $NOME
$ bash mostra_idade

rode os comandos abaixo (para ver var de ambiente e de shell):
====== var de shell/local
$ AMBIENTE=desenvolvimento           => criamos a var de shell (local) AMBiENTE com valor desenvolvimento
$ echo $AMBiENTE                     => mostra a var local chamada desenvolvimento
$ AMBIENTE=                          => zeramos/apagamos a variável
$ echo $AMBIENTE                     => verificando que zeramos msm
====== var de ambiente
$ export AMBIENTE=desenvolvimento    => criamos a var de ambiente AMBiENTE com valor desenvolvimento
$ echo $AMBiENTE                     => mostra a var de ambiente chamada desenvolvimento
$ AMBIENTE=                          => NÃO ZERAMOS a variável
$ echo $AMBiENTE
$ env                                => ela ainda está presente em env !!
$ export -n AMBIENTE                 => AGORA sim a variável foi apagada do env mas não do shell !!
$ unset AMBIENTE                     => para apagar tanto do shell quanto do env !!!

====== variáveis de ambiente do venv
$ echo $PS1                          => toda a formatação do meu prompt "mateus@mateus-VitualBox", pode ser alterada, ver "https://bashrcgenerator.com/"
$ echo $PS2                          => Caracter para quando tem uma quebra de linha com enter dentro de aspas "" ou ''
$ echo $UID                          => ID do meu usuário 
$ echo $HISTFILE                     => Local em que é armazenado o histórico de comandos dados no shell 
$ echo $PATH                         => Quando executamos um comando, o executável desse comando será procurado nos diretórios definidos no valor dessa variável. 
$ echo $MANPATH                      => A variável $PATH indica para o shell onde ele deveria buscar os comandos e da mesma maneira esta variável $PATH ajuda a buscar comandos, existe também a variável $MANPATH. Essa variável diz para o man, onde ele deve procurar os manuais. Se a variável é vazia ele procura um arquivo de configuração e este arquivo está em cat /etc/manpath.config

====== variável de ambiente EDITOR
==== Entrar no editor vim
$ EDITOR=/usr/bin/vi
$ /usr/bin/vi                        => para entrar no editor
$ :q                                 => para sair do editor
==== Entrar no editor Nano
$ EDITOR=/bin/nano
$ /bin/nano

================================================================================================================================================================

====== Estender o volume da máquina virtual=====================================================================================================================
ver : https://sourcedigit.com/16391-change-ownership-set-write-permission-on-ext4-partition-in-linux-ubuntu/
    : https://www.youtube.com/watch?v=cF4qIpOvkkA
    : https://www.youtube.com/watch?v=6wXZ38RfKxg


=> no Windows, no cmd, na pasta do Virtual Box

vboxmanage modifyhd "D:\UBUNTU\Ubuntu 20.04.vdi" --resize 51200  => modifica a maquina para 50GB -- 50*1024=51200

=> No linux particionar com o 'Gparter', montar a unidade em 'Discos' e depois:

$ sudo fdisk -l                     => ver o nome das partições
$ sudo blkid                        => mostra os UUID(s) das unidades
$ ll /media/                        => mostra as unidades montadas
$ sudo chown mateus:mateus /media/mateus/D   => conseguir permissão de leitura e gravação no disco D, já montado, do tipo ext4 que foi particionado no Gparter
================================================================================================================================================================

 ======= instaláveis para tornar o Linux em um ambiente de desenvolvimento======================================================================================
$ sudo apt install build-essential default-jdk libssl-dev exuberant-ctags ncurses-term ack-grep silversearch-ag fontconfig imagemagick libmagickwand-dev software-properties-commom git vim-gtk3 curl perl -y
================================================================================================================================================================



